<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MUJ.TV - Network Connectivity Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .success { background: rgba(76, 175, 80, 0.3); }
        .error { background: rgba(244, 67, 54, 0.3); }
        .warning { background: rgba(255, 152, 0, 0.3); }
        .info { background: rgba(33, 150, 243, 0.3); }
        button {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #45a049; }
        button:disabled { background: #666; cursor: not-allowed; }
        pre {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
        }
        .ice-servers {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .ice-server {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåê MUJ.TV Network Connectivity Test</h1>
        <p>This page helps diagnose WebRTC connectivity issues across different networks.</p>

        <div class="test-section">
            <h2>üîß Connection Test</h2>
            <button onclick="testBasicConnectivity()">Test Basic Connectivity</button>
            <button onclick="testSTUNServers()">Test STUN Servers</button>
            <button onclick="testTURNServers()">Test TURN Servers</button>
            <button onclick="testFullWebRTC()">Test Full WebRTC</button>
            <div id="results"></div>
        </div>

        <div class="test-section">
            <h2>üìä Network Information</h2>
            <div id="networkInfo"></div>
        </div>

        <div class="test-section">
            <h2>üåç ICE Servers Configuration</h2>
            <div class="ice-servers" id="iceServers"></div>
        </div>

        <div class="test-section">
            <h2>üìù Logs</h2>
            <pre id="logs"></pre>
        </div>
    </div>

    <script>
        const logs = [];
        const resultsDiv = document.getElementById('results');
        const networkInfoDiv = document.getElementById('networkInfo');
        const iceServersDiv = document.getElementById('iceServers');
        const logsDiv = document.getElementById('logs');

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            logs.push(logEntry);
            logsDiv.textContent = logs.join('\n');
            logsDiv.scrollTop = logsDiv.scrollHeight;
            console.log(message);
        }

        function addResult(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `status ${type}`;
            div.textContent = message;
            resultsDiv.appendChild(div);
        }

        // ICE Servers configuration
        const iceServers = [
            { urls: 'stun:stun.l.google.com:19302', type: 'STUN' },
            { urls: 'stun:stun1.l.google.com:19302', type: 'STUN' },
            { urls: 'stun:stun2.l.google.com:19302', type: 'STUN' },
            { urls: 'stun:stun3.l.google.com:19302', type: 'STUN' },
            { urls: 'stun:stun4.l.google.com:19302', type: 'STUN' },
            { urls: 'stun:stun.services.mozilla.com', type: 'STUN' },
            { urls: 'stun:stun.stunprotocol.org:3478', type: 'STUN' },
            { urls: 'stun:stun.voiparound.com', type: 'STUN' },
            { urls: 'stun:stun.voipbuster.com', type: 'STUN' },
            { urls: 'stun:stun.voipstunt.com', type: 'STUN' },
            { urls: 'stun:stun.voxgratia.org', type: 'STUN' },
            { urls: 'stun:stun.xten.com', type: 'STUN' },
            { 
                urls: 'turn:openrelay.metered.ca:80',
                username: 'openrelayproject',
                credential: 'openrelayproject',
                type: 'TURN'
            },
            { 
                urls: 'turn:openrelay.metered.ca:443',
                username: 'openrelayproject',
                credential: 'openrelayproject',
                type: 'TURN'
            },
            { 
                urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                username: 'openrelayproject',
                credential: 'openrelayproject',
                type: 'TURN'
            }
        ];

        // Display ICE servers
        function displayIceServers() {
            iceServersDiv.innerHTML = '';
            iceServers.forEach(server => {
                const div = document.createElement('div');
                div.className = 'ice-server';
                div.innerHTML = `
                    <strong>${server.type}</strong><br>
                    <code>${server.urls}</code>
                    ${server.username ? `<br>Username: ${server.username}` : ''}
                `;
                iceServersDiv.appendChild(div);
            });
        }

        // Test basic connectivity
        async function testBasicConnectivity() {
            log('Testing basic connectivity...');
            addResult('Testing basic connectivity...', 'info');
            
            try {
                // Test if WebRTC is supported
                if (!window.RTCPeerConnection) {
                    throw new Error('WebRTC not supported');
                }
                addResult('‚úÖ WebRTC is supported', 'success');
                log('WebRTC is supported');

                // Test if getUserMedia is supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('getUserMedia not supported');
                }
                addResult('‚úÖ getUserMedia is supported', 'success');
                log('getUserMedia is supported');

                // Test network connectivity
                const response = await fetch('https://httpbin.org/ip');
                const data = await response.json();
                addResult(`‚úÖ Network connectivity: ${data.origin}`, 'success');
                log(`Network connectivity: ${data.origin}`);

            } catch (error) {
                addResult(`‚ùå Basic connectivity test failed: ${error.message}`, 'error');
                log(`Basic connectivity test failed: ${error.message}`);
            }
        }

        // Test STUN servers
        async function testSTUNServers() {
            log('Testing STUN servers...');
            addResult('Testing STUN servers...', 'info');
            
            const stunServers = iceServers.filter(s => s.type === 'STUN');
            
            for (const server of stunServers) {
                try {
                    const pc = new RTCPeerConnection({ iceServers: [server] });
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('Timeout'));
                        }, 5000);
                        
                        pc.onicegatheringstatechange = () => {
                            if (pc.iceGatheringState === 'complete') {
                                clearTimeout(timeout);
                                resolve();
                            }
                        };
                    });
                    
                    addResult(`‚úÖ STUN server ${server.urls} working`, 'success');
                    log(`STUN server ${server.urls} working`);
                    pc.close();
                    
                } catch (error) {
                    addResult(`‚ùå STUN server ${server.urls} failed: ${error.message}`, 'error');
                    log(`STUN server ${server.urls} failed: ${error.message}`);
                }
            }
        }

        // Test TURN servers
        async function testTURNServers() {
            log('Testing TURN servers...');
            addResult('Testing TURN servers...', 'info');
            
            const turnServers = iceServers.filter(s => s.type === 'TURN');
            
            for (const server of turnServers) {
                try {
                    const pc = new RTCPeerConnection({ iceServers: [server] });
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('Timeout'));
                        }, 10000);
                        
                        pc.onicegatheringstatechange = () => {
                            if (pc.iceGatheringState === 'complete') {
                                clearTimeout(timeout);
                                resolve();
                            }
                        };
                    });
                    
                    addResult(`‚úÖ TURN server ${server.urls} working`, 'success');
                    log(`TURN server ${server.urls} working`);
                    pc.close();
                    
                } catch (error) {
                    addResult(`‚ùå TURN server ${server.urls} failed: ${error.message}`, 'error');
                    log(`TURN server ${server.urls} failed: ${error.message}`);
                }
            }
        }

        // Test full WebRTC connection
        async function testFullWebRTC() {
            log('Testing full WebRTC connection...');
            addResult('Testing full WebRTC connection...', 'info');
            
            try {
                const pc = new RTCPeerConnection({ iceServers });
                
                // Get local stream
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                stream.getTracks().forEach(track => pc.addTrack(track, stream));
                
                addResult('‚úÖ Local media stream obtained', 'success');
                log('Local media stream obtained');
                
                // Create offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                addResult('‚úÖ Offer created successfully', 'success');
                log('Offer created successfully');
                
                // Wait for ICE gathering
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('ICE gathering timeout'));
                    }, 15000);
                    
                    pc.onicegatheringstatechange = () => {
                        log(`ICE gathering state: ${pc.iceGatheringState}`);
                        if (pc.iceGatheringState === 'complete') {
                            clearTimeout(timeout);
                            resolve();
                        }
                    };
                    
                    pc.onicecandidate = (event) => {
                        if (event.candidate) {
                            log(`ICE candidate: ${event.candidate.type} ${event.candidate.protocol}`);
                        }
                    };
                });
                
                addResult('‚úÖ ICE gathering completed', 'success');
                log('ICE gathering completed');
                
                // Get connection stats
                const stats = await pc.getStats();
                let candidateCount = 0;
                stats.forEach(report => {
                    if (report.type === 'candidate-pair') {
                        candidateCount++;
                    }
                });
                
                addResult(`‚úÖ Found ${candidateCount} candidate pairs`, 'success');
                log(`Found ${candidateCount} candidate pairs`);
                
                pc.close();
                stream.getTracks().forEach(track => track.stop());
                
            } catch (error) {
                addResult(`‚ùå Full WebRTC test failed: ${error.message}`, 'error');
                log(`Full WebRTC test failed: ${error.message}`);
            }
        }

        // Display network information
        function displayNetworkInfo() {
            const info = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine,
                connection: navigator.connection ? {
                    effectiveType: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink,
                    rtt: navigator.connection.rtt
                } : 'Not available'
            };
            
            networkInfoDiv.innerHTML = `
                <div class="status info">
                    <strong>Browser:</strong> ${info.userAgent}<br>
                    <strong>Platform:</strong> ${info.platform}<br>
                    <strong>Language:</strong> ${info.language}<br>
                    <strong>Cookies:</strong> ${info.cookieEnabled ? 'Enabled' : 'Disabled'}<br>
                    <strong>Online:</strong> ${info.onLine ? 'Yes' : 'No'}<br>
                    <strong>Connection:</strong> ${typeof info.connection === 'object' ? 
                        `${info.connection.effectiveType} (${info.connection.downlink}Mbps, ${info.connection.rtt}ms RTT)` : 
                        info.connection}
                </div>
            `;
        }

        // Initialize
        window.onload = function() {
            log('Network connectivity test page loaded');
            displayIceServers();
            displayNetworkInfo();
        };
    </script>
</body>
</html>
